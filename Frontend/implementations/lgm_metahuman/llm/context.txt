This is a context for your future tasks. Sections are given by:
\ContextSection{File tree}
<file tree>

\ContextSection{Files}
\File{<path>}
\BinaryFile{<path>, <name>}


\ContextSection{File tree}
- src/
  - components/
    - App.tsx
    - PixelStreamingWrapper.tsx
  - lgm/
    - client/
      - LgmClient.ts
      - LgmData.ts
    - stores/
      - LgmChatStore.ts
      - LgmStore.ts
      - LgmWebRTCStore.ts
    - ui/
      - components/
        - chat/
          - LgmChat.tsx
          - LgmChatMessages.tsx
          - LgmVideoStream.tsx
        - LgmRolePicker.tsx
        - LgmUeControls.tsx
        - LgmUnreal.tsx
      - LgmInstructorUi.tsx
      - LgmStudentUi.tsx
      - LgmStyles.tsx
      - LgmSupervisorUi.tsx
    - LgmConfig.ts
    - LgmUiWrapper.tsx
  - index.tsx


\ContextSection{Files}


\File{src/lgm/LgmConfig.ts}
export abstract class LgmConfig {
    static LGM_SERVER = 'ws://localhost:8119';
    static MH_SERVER = 'wss://172.20.10.2';
}


\File{src/lgm/stores/LgmWebRTCStore.ts}
import { LgmStore } from './LgmStore';
import { LgmApiMessage, LgmRole } from '../client/LgmData';
import { autorun, makeAutoObservable, ObservableMap } from 'mobx';

interface PeerConnection {
    connection: RTCPeerConnection;
    mediaStream: MediaStream | null;
}

export class LgmWebRTCStore {
    private base: LgmStore;
    private peerConnections: ObservableMap<string, PeerConnection>;
    localStream?: MediaStream = undefined;

    constructor(base: LgmStore) {
        this.base = base;
        this.peerConnections = new ObservableMap();
        this.base.client.messages.subscribe((message) => this.onMessage(message));
        makeAutoObservable(this);
        navigator.mediaDevices?.getUserMedia({ video: true, audio: true }).then((stream) => this.localStream = stream);
    }

    get peerStreams() {
        return Array.from(this.peerConnections.values()).map((peer) => peer.mediaStream).filter((stream) => stream !== null) as MediaStream[];
    }

    private async onMessage(message: LgmApiMessage) {
        switch (message.type) {
            case 'offer':
                await this.handleOffer(message);
                break;
            case 'answer':
                await this.handleAnswer(message);
                break;
            case 'ice-candidate':
                await this.handleIceCandidate(message);
                break;
        }
    }

    async createOffer(peerId: string) {
        const peerConnection = await this.createPeerConnection(peerId);

        // Create the offer
        const offer = await peerConnection.connection.createOffer();
        await peerConnection.connection.setLocalDescription(offer);

        // Send the offer to the peer via WebSocket
        this.base.client.broadcast({
            type: 'offer',
            offer,
            from: this.base.user.id,
            to: peerId
        });
    }

    // Handle receiving an offer from a peer
    private async handleOffer(message: LgmApiMessage) {
        const { from, offer, to } = message;
        if (to !== this.base.user.id) {
            return;
        }

        const peerConnection = await this.createPeerConnection(from!);

        // Set the remote description
        await peerConnection.connection.setRemoteDescription(new RTCSessionDescription(offer));

        // Create an answer
        const answer = await peerConnection.connection.createAnswer();
        await peerConnection.connection.setLocalDescription(answer);

        // Send the answer back to the peer via WebSocket
        this.base.client.broadcast({
            type: 'answer',
            answer,
            from: this.base.user.id,
            to: from
        });
    }

    // Handle receiving an answer from a peer
    private async handleAnswer(message: LgmApiMessage) {
        const { from, answer, to } = message;
        if (to !== this.base.user.id) {
            return;
        }

        const peerConnection = this.peerConnections.get(from!);
        if (peerConnection) {
            await peerConnection.connection.setRemoteDescription(new RTCSessionDescription(answer));
        }
    }

    // Handle receiving an ICE candidate from a peer
    private async handleIceCandidate(message: LgmApiMessage) {
        const { from, candidate, to } = message;
        if (to !== this.base.user.id) {
            return;
        }

        const peerConnection = this.peerConnections.get(from!);
        if (peerConnection && candidate) {
            await peerConnection.connection.addIceCandidate(new RTCIceCandidate(candidate));
        }
    }

    // Create and initialize a new RTCPeerConnection
    private async createPeerConnection(peerId: string): Promise<PeerConnection> {
        if (this.peerConnections.has(peerId)) {
            return this.peerConnections.get(peerId)!;
        }

        const peerConnection = new RTCPeerConnection();

        // Handle ICE candidates
        peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                this.base.client.broadcast({
                    type: 'ice-candidate',
                    candidate: event.candidate,
                    from: this.base.user.id,
                    to: peerId
                });
            }
        };

        // Handle track event to receive remote stream
        peerConnection.ontrack = (event) => {
            const peer = this.peerConnections.get(peerId);
            if (peer) {
                peer.mediaStream = event.streams[0];
            }
        };

        peerConnection.onconnectionstatechange = (event) => {
            if (peerConnection.connectionState === 'disconnected' || peerConnection.connectionState === 'closed') {
                this.closePeerConnection(peerId);
            }
        };

        peerConnection.oniceconnectionstatechange = (event) => {
            if (peerConnection.iceConnectionState === 'disconnected' || peerConnection.iceConnectionState === 'closed') {
                this.closePeerConnection(peerId);
            }
        };

        // If the user is a student, they will add their local media stream to the connection
        if (this.base.user.role === LgmRole.student) {
            if (!this.localStream) {
                this.localStream = await navigator.mediaDevices?.getUserMedia({ video: true, audio: true });
            }
            this.localStream?.getTracks().forEach((track) => peerConnection.addTrack(track, this.localStream));
        }

        // Store the peer connection
        const peer = { connection: peerConnection, mediaStream: null } as PeerConnection;
        this.peerConnections.set(peerId, peer);

        return peer;
    }

    // Close and remove a peer connection
    private closePeerConnection(peerId: string) {
        const peer = this.peerConnections.get(peerId);
        if (peer) {
            peer.connection.close();
            this.peerConnections.delete(peerId);
        }
    }
}



\File{src/lgm/stores/LgmChatStore.ts}
import { makeAutoObservable } from 'mobx';
import { LgmApiMessage, LgmChatMessage } from '../client/LgmData';
import { LgmStore } from './LgmStore';

export class LgmChatStore {
    private base: LgmStore;
    messages: LgmChatMessage[] = [];

    constructor(base: LgmStore) {
        this.base = base;
        makeAutoObservable(this);

        this.base.client.messages.subscribe((message) => this.onMessage(message));
    }

    send(message: string) {
        const lgmMessage = {
            id: Math.random().toString(),
            from: this.base.user.id,
            role: this.base.user.role,
            message: message,
            ts: Date.now()
        } as LgmChatMessage;
        this.messages.push(lgmMessage);
        this.base.client.broadcast({
            type: 'chat',
            message: lgmMessage
        });
    }

    private onMessage(message: LgmApiMessage) {
        switch (message.type) {
            case 'requestChatHistory':
                this.base.client.broadcast({
                    type: 'chatHistory',
                    chat: this.messages
                });
                break;
            case 'chatHistory':
                const chatHistory = message.chat as LgmChatMessage[];
                this.messages = [...this.messages, ...chatHistory];
                const uniqueMessages: { [k: string]: LgmChatMessage } = {};
                for (const message of this.messages) {
                    uniqueMessages[message.id] = message;
                }
                this.messages = Object.values(uniqueMessages);
                this.messages.sort((a, b) => a.ts - b.ts);
                break;
            case 'chat':
                const chatMessage = message.message as LgmChatMessage;
                this.messages.push(chatMessage);
                this.messages.sort((a, b) => a.ts - b.ts);
                break;
        }
    }
}


\File{src/lgm/stores/LgmStore.ts}
import { autorun, makeAutoObservable, ObservableMap } from 'mobx';
import { LgmClient } from '../client/LgmClient';
import { LgmConfig } from '../LgmConfig';
import { LgmApiMessage, LgmChatMessage, LgmRole, LgmUser } from '../client/LgmData';
import { LgmChatStore } from './LgmChatStore';
import { LgmWebRTCStore } from './LgmWebRTCStore';
import { createContext } from 'react';

export const LgmStoreContext = createContext<LgmStore | undefined>(undefined);

export class LgmStore {
    user: LgmUser = {
        id: Math.random().toString(36).substring(7),
        role: undefined,
        name: undefined
    };
    client = new LgmClient(
        LgmConfig.LGM_SERVER,
        this.user.id
    );

    peers = new ObservableMap<string, LgmPeer>();
    chat: LgmChatStore;
    webrtc: LgmWebRTCStore;

    constructor(role: LgmRole) {
        this.user.role = role;
        this.chat = new LgmChatStore(this);
        this.webrtc = new LgmWebRTCStore(this);

        makeAutoObservable(this);
        this.client.messages.subscribe((message) => this.onMessage(message));

        // Send a ping message every second
        setInterval(() => {
            // remove peers that have been inactive for more than 3 seconds
            const now = new Date();
            this.peers.forEach((peer, id) => {
                if (now.getTime() - peer.date.getTime() > 3000) {
                    this.peers.delete(id);
                }
            });

            // send ping message
            if (this.client.connected && this.user.role !== undefined) {
                this.client.broadcast({
                    type: 'ping',
                    user: this.user
                });
            }
        }, 1000);

        autorun(() => {
            if (this.client.connected) {
                this.client.broadcast({ type: 'requestChatHistory' });
            }
        });
    }

    get showUe() {
        return this.user.role !== undefined;
    }

    private onMessage(message: LgmApiMessage) {
        switch (message.type) {
            case 'ping':
                const user = message.user as LgmUser;
                if (user.role === undefined) {
                    console.error('Received ping message without role', user);
                    return;
                }
                const peer = this.peers.get(user.id);
                if (peer) {
                    peer.update(user);
                } else {
                    this.peers.set(user.id, new LgmPeer(user));
                    this.webrtc.createOffer(user.id);
                }
                break;
        }
    }
}

class LgmPeer {
    date = new Date();
    user: LgmUser;

    constructor(user: LgmUser) {
        this.user = user;
    }

    update(user: LgmUser) {
        this.date = new Date();
        this.user = user;
    }
}


\File{src/lgm/client/LgmData.ts}
export interface LgmChatMessage {
    id: string;
    from: string;
    role: LgmRole;
    message: string;
    ts: number;
}

export interface LgmApiMessage {
    type: string;
    fromUserId?: string;

    [key: string]: any;
}

export interface LgmUser {
    id: string;
    role?: LgmRole;
    name?: string;
}

export enum LgmRole {
    instructor = 'instructor',
    student = 'student',
    supervisor = 'supervisor',
}




\File{src/lgm/client/LgmClient.ts}
import { makeAutoObservable, ObservableMap } from 'mobx';
import { SocketConnector } from 'proto_socket_typescript';
import { LgmApiMessage, LgmChatMessage, LgmUser } from './LgmData';
import { Subject } from 'rxjs';

export class LgmClient {
    connection: SocketConnector;
    connected = false;
    messages = new Subject<LgmApiMessage>();
    private userId: string;

    constructor(wsEndpoint: string, userId: string) {
        // Create a new socket connector
        this.userId = userId;
        this.connection = new SocketConnector(wsEndpoint);
        this.connection.connectedChanges.subscribe((connected) => {
            this.connected = connected;
        });
        this.connection.rx.subscribe((message) => this.onMessage(message));
        makeAutoObservable(this);
    }

    private onMessage(message: string) {
        const messageObject = JSON.parse(message) as LgmApiMessage;
        console.log('LGMMessage:', messageObject.type);
        this.messages.next(messageObject);
    }

    broadcast(message: LgmApiMessage) {
        message.fromUserId = this.userId;
        this.connection.send(JSON.stringify(message));
    }
}




\File{src/index.tsx}
// Copyright Epic Games, Inc. All Rights Reserved.
import React from 'react';
import { createRoot } from 'react-dom/client';
import { App } from './components/App';

document.body.onload = function () {
    // Attach the React app root component to document.body
    createRoot(document.getElementById('root')).render(<App />);
};



\File{src/components/App.tsx}
import React from 'react';
import { LgmUiWrapper } from '../lgm/LgmUiWrapper';

export const App = () => {
    return (
        <div
            style={{
                height: '100%',
                width: '100%'
            }}
        >
            <LgmUiWrapper/>
        </div>
    );
};



\File{src/components/PixelStreamingWrapper.tsx}
// Copyright Epic Games, Inc. All Rights Reserved.

import React, { useEffect, useRef, useState } from 'react';
import {
    Config,
    AllSettings,
    PixelStreaming
} from '@epicgames-ps/lib-pixelstreamingfrontend-ue5.4';
import { LgmStyles } from '../lgm/ui/LgmStyles';

export interface PixelStreamingWrapperProps {
    initialSettings?: Partial<AllSettings>;
    cover?: boolean;
    radius?: boolean;
}

export const PixelStreamingWrapper = ({
                                          initialSettings,
                                          cover,
                                          radius
                                      }: PixelStreamingWrapperProps) => {
    // A reference to parent div element that the Pixel Streaming library attaches into:
    const videoParent = useRef<HTMLDivElement>(null);

    // Pixel streaming library instance is stored into this state variable after initialization:
    const [pixelStreaming, setPixelStreaming] = useState<PixelStreaming>();

    // A boolean state variable that determines if the Click to play overlay is shown:
    const [clickToPlayVisible, setClickToPlayVisible] = useState(false);

    // Run on component mount:
    useEffect(() => {
        if (videoParent.current) {
            // Attach Pixel Streaming library to videoParent element:
            const config = new Config({ initialSettings });
            const streaming = new PixelStreaming(config, {
                videoElementParent: videoParent.current
            });

            // register a playStreamRejected handler to show Click to play overlay if needed:
            streaming.addEventListener('playStreamRejected', () => {
                setClickToPlayVisible(true);
            });

            // Save the library instance into component state so that it can be accessed later:
            setPixelStreaming(streaming);

            // Clean up on component unmount:
            return () => {
                try {
                    streaming.disconnect();
                } catch {
                }
            };
        }
    }, []);

    return (
        <div
            className={cover ? 'object-fit-cover' : ''}
            style={{
                width: '100%',
                height: '100%',
                position: 'relative',
                backgroundColor: 'black',
                overflow: 'hidden',
                borderRadius: radius ? 16 : 0,
                boxShadow: LgmStyles.shadow,
            }}
        >
            <div
                style={{
                    width: '100%',
                    height: '100%'
                }}
                ref={videoParent}
            />
            {clickToPlayVisible && (
                <div
                    style={{
                        position: 'absolute',
                        top: 0,
                        left: 0,
                        width: '100%',
                        height: '100%',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        cursor: 'pointer'
                    }}
                    onClick={() => {
                        pixelStreaming?.play();
                        setClickToPlayVisible(false);
                    }}
                >
                    <div>Click to play</div>
                </div>
            )}
        </div>
    );
};



\File{src/lgm/LgmUiWrapper.tsx}
import { observer } from 'mobx-react-lite';
import { LgmStore, LgmStoreContext } from './stores/LgmStore';
import { LgmRole } from './client/LgmData';
import React, { CSSProperties, useState } from 'react';
import { LgmRolePicker } from './ui/components/LgmRolePicker';
import { LgmInstructorUi } from './ui/LgmInstructorUi';
import { LgmStudentUi } from './ui/LgmStudentUi';
import { LgmSupervisorUi } from './ui/LgmSupervisorUi';

export const LgmUiWrapper = observer(() => {
    const [lgmStore, setLgmStore] = useState<LgmStore | undefined>(undefined);

    return <LgmStoreContext.Provider value={lgmStore}>
        <div style={ComponentStyle}>
            {!lgmStore && <LgmRolePicker onRoleSelected={(role) => setLgmStore(new LgmStore(role))} />}
            {lgmStore?.user.role === LgmRole.instructor && <LgmInstructorUi />}
            {lgmStore?.user.role === LgmRole.student && <LgmStudentUi />}
            {lgmStore?.user.role === LgmRole.supervisor && <LgmSupervisorUi />}
        </div>
    </LgmStoreContext.Provider>;
});

const ComponentStyle: CSSProperties = {
    position: 'absolute',
    top: 0,
    left: 0,
    width: '100%',
    height: '100%',
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    justifyContent: 'center'
};


\File{src/lgm/ui/LgmSupervisorUi.tsx}
import { observer } from 'mobx-react-lite';
import { LgmUnreal } from './components/LgmUnreal';
import { LgmVideoStream } from './components/chat/LgmVideoStream';
import { LgmStoreContext } from '../stores/LgmStore';
import React, { CSSProperties, useContext } from 'react';
import { LgmChat } from './components/chat/LgmChat';
import { LgmStyles } from './LgmStyles';
import { LgmUeControls } from './components/LgmUeControls';

export const LgmSupervisorUi = observer(() => {
    const store = useContext(LgmStoreContext);
    const peerStreams = store.webrtc.peerStreams;
    return <div style={RootStyle}>
        <div style={StreamsStyle}>
            <div style={LgmUnrealContainerStyle}>
                <LgmUnreal cover radius />
            </div>
            {!!peerStreams?.length && <LgmVideoStream
                stream={peerStreams[0]}
                style={VideoStyle}
            />}
        </div>
        <div style={ChatContainerStyle}>
            <LgmChat />
        </div>
    </div>;
});

const RootStyle: CSSProperties = {
    position: 'absolute',
    left: 0,
    top: 0,
    right: 0,
    bottom: 0,
    display: 'flex',
    padding: 16,
    gap: 16
};

const ChatContainerStyle: CSSProperties = {
    display: 'flex',
    flexGrow: 1,
    flexBasis: 0,
    maxWidth: 400,
};

const StreamsStyle: CSSProperties = {
    flexGrow: 1,
    flexBasis: 0,
    maxWidth: '82vh',
    display: 'flex',
    flexDirection: 'column',
    gap: 16,
    justifyContent: 'center',
    margin: 'auto'
};

const LgmUnrealContainerStyle: CSSProperties = {
    aspectRatio: '16 / 9'
};

const VideoStyle: CSSProperties = {
    aspectRatio: '16 / 9',
    objectFit: 'cover',
    boxShadow: LgmStyles.shadow
};


\File{src/lgm/ui/LgmStudentUi.tsx}
import { observer } from 'mobx-react-lite';
import { CSSProperties, useContext } from 'react';
import { LgmUnreal } from './components/LgmUnreal';
import { LgmVideoStream } from './components/chat/LgmVideoStream';
import { LgmStoreContext } from '../stores/LgmStore';

export const LgmStudentUi = observer(() => {
    const store = useContext(LgmStoreContext);
    return <div style={RootStyle}>
        <LgmUnreal cover />
        {store.webrtc.localStream && <LgmVideoStream
            stream={store.webrtc.localStream}
            style={VideoStyle}
            muted={true} />}
    </div>;
});

const RootStyle: CSSProperties = {
    position: 'absolute',
    right: 0,
    left: 0,
    top: 0,
    bottom: 0,
    display: 'flex'
};

const VideoStyle: CSSProperties = {
    position: 'absolute',
    bottom: 16,
    right: 16,
    backgroundColor: 'gray',
    width: 240,
    height: 180
};


\File{src/lgm/ui/LgmStyles.tsx}
export abstract class LgmStyles {
    static readonly shadow = '0 0 16px rgba(255, 255, 255, 0.3)';
}


\File{src/lgm/ui/LgmInstructorUi.tsx}
import { observer } from 'mobx-react-lite';
import { LgmUnreal } from './components/LgmUnreal';
import { LgmVideoStream } from './components/chat/LgmVideoStream';
import { LgmStoreContext } from '../stores/LgmStore';
import React, { CSSProperties, useContext } from 'react';
import { LgmChat } from './components/chat/LgmChat';
import { LgmStyles } from './LgmStyles';
import { LgmUeControls } from './components/LgmUeControls';

export const LgmInstructorUi = observer(() => {
    const store = useContext(LgmStoreContext);
    const peerStreams = store.webrtc.peerStreams;
    return <div style={RootStyle}>
        <div style={StreamsStyle}>
            <div style={LgmUnrealContainerStyle}>
                <LgmUnreal
                    interactive={true}
                    cover radius />
            </div>
            {!!peerStreams?.length && <LgmVideoStream
                stream={peerStreams[0]}
                style={VideoStyle}
            />}
        </div>
        <div style={SideUiContainerStyle} className={'mobile-column desktop-row'}>
            <LgmUeControls />
            <LgmChat />
        </div>
    </div>;
});

const RootStyle: CSSProperties = {
    position: 'absolute',
    left: 0,
    top: 0,
    right: 0,
    bottom: 0,
    display: 'flex',
    padding: 16,
    gap: 16
};

const SideUiContainerStyle: CSSProperties = {
    display: 'flex',
    gap: 16,
    flexGrow: 1,
    width: 0
};

const StreamsStyle: CSSProperties = {
    flexGrow: 1,
    flexBasis: 0,
    maxWidth: '82vh',
    display: 'flex',
    flexDirection: 'column',
    gap: 16,
    justifyContent: 'center'
};

const LgmUnrealContainerStyle: CSSProperties = {
    aspectRatio: '16 / 9'
};

const VideoStyle: CSSProperties = {
    aspectRatio: '16 / 9',
    objectFit: 'cover',
    boxShadow: LgmStyles.shadow
};


\File{src/lgm/ui/components/LgmUnreal.tsx}
import { observer } from 'mobx-react-lite';
import React, { useContext } from 'react';
import { LgmStoreContext } from '../../stores/LgmStore';
import { LgmConfig } from '../../LgmConfig';
import { PixelStreamingWrapper } from '../../../components/PixelStreamingWrapper';

interface LgmUnrealProps {
    interactive?: boolean;
    cover?: boolean;
    radius?: boolean;
}

export const LgmUnreal = observer((props: LgmUnrealProps) => {
    const store = useContext(LgmStoreContext);
    if (!store) {
        return null;
    }

    return <PixelStreamingWrapper
        cover={props.cover}
        radius={props.radius}
        initialSettings={{
            AutoPlayVideo: true,
            GamepadInput: !!props.interactive,
            KeyboardInput: !!props.interactive,
            MouseInput: !!props.interactive,
            TouchInput: !!props.interactive,
            StreamerAutoJoinInterval: 5000,
            AutoConnect: true,
            ss: LgmConfig.MH_SERVER,
            StartVideoMuted: false,
            HoveringMouse: false,
            WaitForStreamer: true
        }}
    />;
});


\File{src/lgm/ui/components/LgmUeControls.tsx}
import { observer } from 'mobx-react-lite';
import { LgmStoreContext } from '../../stores/LgmStore';
import { CSSProperties, useContext } from 'react';
import { LgmStyles } from '../LgmStyles';

export const LgmUeControls = observer(() => {
    const store = useContext(LgmStoreContext);

    return <div style={RootStyle}>
        <div style={HeaderStyle}>Controls</div>
    </div>;
});

const RootStyle: CSSProperties = {
    borderRadius: 16,
    border: '1px solid #3c3c3c',
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    overflow: 'hidden',
    display: 'flex',
    flexDirection: 'column',
    flexGrow: 1,
    flexBasis: 0,
};

const HeaderStyle: CSSProperties = {
    height: 54,
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    fontWeight: 'bold',
    fontSize: 20
};



\File{src/lgm/ui/components/LgmRolePicker.tsx}
import { observer } from 'mobx-react-lite';
import { LgmRole } from '../../client/LgmData';
import React, { CSSProperties } from 'react';

interface LgmRolePickerProps {
    onRoleSelected: (role: LgmRole) => void;
}

export const LgmRolePicker = observer((props: LgmRolePickerProps) => {
    return <div style={FlexRowStyle}>
        <button onClick={() => props.onRoleSelected(LgmRole.instructor)}>
            Instructor
        </button>
        <button onClick={() => props.onRoleSelected(LgmRole.student)}>
            Student
        </button>
        <button onClick={() => props.onRoleSelected(LgmRole.supervisor)}>
            Supervisor
        </button>
    </div>;
});

const FlexRowStyle: CSSProperties = {
    display: 'flex', gap: '8px'
};


\File{src/lgm/ui/components/chat/LgmVideoStream.tsx}
import { observer } from 'mobx-react-lite';
import { CSSProperties } from 'react';

interface LgmVideoStreamProps {
    stream: MediaStream;
    style?: CSSProperties;
    muted?: boolean;
}

export const LgmVideoStream = observer((props: LgmVideoStreamProps) => {
    return <div style={{
        borderRadius: '16px',
        overflow: 'hidden',
        ...props.style
    }}>
        <video
            key={props.stream.id}
            autoPlay
            playsInline
            muted={props.muted}
            style={{
                width: '100%',
                height: '100%',
                objectFit: 'cover'
            }}
            ref={(video) => {
                if (video) {
                    video.srcObject = props.stream;
                }
            }}
        />
    </div>;
});


\File{src/lgm/ui/components/chat/LgmChatMessages.tsx}
import { observer } from 'mobx-react-lite';
import { LgmStoreContext } from '../../../stores/LgmStore';
import { CSSProperties, useContext } from 'react';

export const LgmChatMessages = observer(() => {
    const store = useContext(LgmStoreContext);
    return <>
        {store.chat.messages.map((message, index) => {
            const isSelf = store.user.role === message.role;
            return <div key={message.id} style={{
                alignSelf: isSelf ? 'end' : 'start',
                ...MessageStyle,
                borderTopLeftRadius: isSelf ? 16 : 0,
                borderBottomRightRadius: isSelf ? 0 : 16
            }}>
                {message.message}
            </div>;
        })}
    </>;
});

const MessageStyle: CSSProperties = {
    borderRadius: 16,
    padding: 16,
    width: '80%',
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
    fontWeight: 'normal',
    fontSize: 14
};


\File{src/lgm/ui/components/chat/LgmChat.tsx}
import { observer } from 'mobx-react-lite';
import { LgmStoreContext } from '../../../stores/LgmStore';
import React, { CSSProperties, useContext, useState } from 'react';
import { Send } from '@mui/icons-material';
import useWave from 'use-wave';
import { LgmChatMessages } from './LgmChatMessages';

export const LgmChat = observer(() => {
    const store = useContext(LgmStoreContext);
    const [text, setText] = useState('');
    const wave = useWave();
    return <div style={RootStyle}>
        <div style={HeaderStyle}>Chat</div>
        <div style={MessagesContainerStyle}>
            <LgmChatMessages/>
        </div>
        <div style={TextboxContainerStyle}>
            <input
                onKeyDown={(e) => {
                    if (e.key === 'Enter' && text.length > 0) {
                        store.chat.send(text);
                        setText('');
                    }
                }}
                onChange={(e) => setText(e.target.value)}
                value={text}
                type={'text'}
                style={TextboxStyle}
                placeholder={'Type a message...'}
            />
            <div
                className={'hoverable'}
                ref={wave}
                onClick={() => {
                    if (text.length > 0) {
                        store.chat.send(text);
                        setText('');
                    }
                }}
                style={TextboxSendButtonStyle}>
                <Send />
            </div>
        </div>
    </div>;
});

const RootStyle: CSSProperties = {
    borderRadius: 16,
    border: '1px solid #3c3c3c',
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    overflow: 'hidden',
    display: 'flex',
    flexDirection: 'column',
    flexGrow: 1,
    padding: 8,
    flexBasis: 0,
};

const HeaderStyle: CSSProperties = {
    height: 54,
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    fontWeight: 'bold',
    fontSize: 20
};

const MessagesContainerStyle: CSSProperties = {
    flexGrow: 1,
    height: 0,
    display: 'flex',
    flexDirection: 'column',
    gap: 8,
    justifyContent: 'end',
    margin: '16px 0 16px 0',
};

const TextboxContainerStyle: CSSProperties = {
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    height: 54,
    borderRadius: 16,
    display: 'flex',
    padding: '0 8px 0 8px',
    alignItems: 'center'
};

const TextboxStyle: CSSProperties = {
    flexGrow: 1,
    width: 0,
    border: 'none',
    outline: 'none',
    backgroundColor: 'transparent',
    height: '100%',
    color: 'white',
    fontSize: 14,
};

const TextboxSendButtonStyle: CSSProperties = {
    borderRadius: 100,
    width: 40,
    height: 40,
    cursor: 'pointer',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center'
};
